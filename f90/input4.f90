SUBROUTINE input4 (nmat,unitx,tape,bcdopt)
     
!     THIS SUBROUTINE IS CALLED ONLY BY INPTT4. IT READS USER-SUPPLIED
!     TAPE (OR DISC FILE), AS GENERATED BY COSMIC or MSC/OUTPUT4 MODULE,
!     AND CREATES THE CORRESPONDING MATRIX DATA BLOCKS.
 
!     INPUTT4 MODULE DOES NOT HANDLE TABLE DATA BLOCKS.
 
!     DUE TO INSUFFICEINT DOCUMENTATION IN MSC USER MANUAL, THIS INPUT4
!     MAY NOT WORK WITH BCD/ASCII DATA AS GENERATED BY MSC/OUTPUT4
 
!     MATRICES CAN BE IN S.P. OR D.P.; DENSE OR SPARSE.
!     NO MATRIX CONVERSION IN THIS ROUTINE
!     i.e. TYPE OF MATRIX OUT = TYPE OF MATRIX IN
 
!     DEFINITION OF DENSE AND SPARSE MATRICES IN THIS SUBROUTINE -
!     DENSE MATRIX IS PROCESSED FROM FIRST TO LAST NONZERO TERMS OF
!     COLUMNS, AND SPARSE MATRIX IS PROCESSED BY STRINGS.
 
!     WRITTEN BY G.CHAN/UNISYS            JUNE  1989
!     LAST REVISION WITH MAJOR CHANGES    MARCH 1993
 
!     NMAT   = NUMBER OF MATRICES (5 MAX) WRITTEN ON USER'S TAPE
!     UNITX  = INPUT TAPE LOGICAL UNIT*, INTEGER, NO DEFAULT
!     TAPE   = TAPE READ CONTROL
!            = 0  NO ADDITIONAL ACTION BEFORE READ
!            =-1  REWIND UNITX  BEFORE READ
!            =-2  REWIND UNITX  AT END
!            =-3  BOTH
!     BCDOPT = 1  INPUT TAPE IN BINARY FORMAT
!            = 2  INPUT TAPE IN ASCII  FORMAT
!                 IF INPUT MATRIX IS IN S.P., I13 IS USED FOR INTEGER,
!                 AND 10E13.6 FOR S.P.REAL DATA
!                 IF INPUT MATRIX IS IN D.P., I16 IS USED FOR INTEGER,
!                 AND 8D16.9 FOR D.P.REAL DATA
!            = 3  SAME AS BCDOPT=2, EXECPT THAT I16 AND 8E16.9 ARE USED
!                 FOR INTEGERS AND S.P.REAL DATA. (BCDOPT=3 IS USED ONLY
!                 IN MACHINES WITH LONG WORDS (60 OR MORE BITS PER WORD)
!           NOTE- MATRIX HEADER RECORD IS NOT AFFECTED BY ABOVE FORMAT
!                 CHANGES. IT IS WRITTEN OUT BY (1X,4I13,5X,2A4)
!     P4     =-4,-2,-1,0,.GE.1, SEE P4 IN INPTT4
 
!     OUTFIL = UP TO 5 OUTPUT GINO DATA BLOCKS (MATRIX ONLY)
!              IF ANY OF THE OUTPUT DB IS PURGED, THE CORRESPONDING
!              MATRIX ON INPUT TAPE WILL BE SKIPPED.
 
!     * LOGICAL UNIT  vs.  GINO FILE NAME
!              ------     ----------------------
!                11        UT1  (CDC ONLY)
!                12        UT2  (CDC ONLY
!                14        INPT (VAX,UNIVAC)
!                15        INP1 (VAX,UNIVAC,IBM)
!                16        INP2      :
!                17        INP3      :
!                 :          :       :
!                23        INP9      :
!                24        INPT (IBM ONLY)
 
 
!     EACH MATRIX WAS WRITTEN AS FOLLOWS (IN BINARY OR ASCII), 4 INTEGER
!     WORDS + FILE NAME
!                1) NO. OF COLUMNS
!                2) NO. OF ROWS
!                3) FORM (NASTRAN  1 TO 8)
!                4) TYPE (NASTRAN  1 TO 4)
!              5,6) FILE NAME (BCD)
 
!     A  RECORD WAS WRITTEN FOR EACH NON-ZERO COLUMN
!        A) DENSE MATRIX:
!                1) COLUMN NO.
!                2) ROW POSITION OF FIRST NON-ZERO ELEMENT
!                3) NO. OF WORDS IN THIS COLUMN, ZEROS INCLUDED, FROM
!                   THE FIRST TO LAST NON-ZERO TERMS.
!                4) DATA VALUES FOR THIS COLUMN (REAL)
!        B) SPARSE MATRIX:
!                1) COLUMN NO.
!                2) ZERO (THIS ZERO IS THE SPARSE MATRIX FLAG)
!                3) NO. OF WORDS IN THIS COLUMN
!                4) DATA OF ONE OR MORE STRINGS.
 
 
!     EXAMPLE 1 - INPUT TAPE INP1 (UNIT 15) CONTAINS 5 MATRICES,
!     =========   WRITTEN BY COSMIC/OUTPUT4, BINARY.
!                 WE WANT TO COPY
!                 FILE 3 TO A,
!                 FILE 4 TO B
 
!     INPUTT4  /,,A,B,/-1/15      $ REWIND, READ & ECHO HEADER RECORD
 
 
!     EXAMPLE 2 - TO COPY THE FIRST 2 FILES OF A UNFORMATTED TAPE INP2
!     =========   (UNIT 16), WRITTEN BY MSC/OUTPUT4, DENSE MATRIX
 
!     INPUTT4  /A,B,,,/-3/16//-4  $
 
!     EXAMPLE 3 - TO COPY THE FIRST 2 FILES OF A FORMATTED ASCII TAPE
!     =========   INPT (UNIT 14), WRITTEN BY COSMIC/OUTPUT4, SPARSE
!                 MATRIX
 
!     INPUTT4  /A,B,,,/-3/-14//1  $
 
!     EXAMPLE 4 - SEE DEMO PROBLEM T00001A TO INPUT VARIOUS DATA BLOCKS
!     =========   (SQUARE, RECTANGULAR, ROW-VECTOR, 'COLUMN' VECOR,
!                 DIAGONAL, IDENTITY, SYMMETRIC) INTO NASTRAN SYSTEM
!                 USING MSC, ASCII FORMAT FILES.
 
!     A NOTE FOR FUTURE IMPROVEMENT, G.CHAN 4/93 -
!     IF INPUT MATRIX IS SYMMETRIC, MAKE AN OPTION TO INPUT ONLY THE
!     LOWER TRIANGULAR PORTION OF THE MATRIX, AND OBTAIN THE UPPER
!     PROTION THRU SYMMETRY.
 
 
 
 INTEGER, INTENT(IN)                      :: nmat
 INTEGER, INTENT(IN OUT)                  :: unitx
 INTEGER, INTENT(IN OUT)                  :: tape
 INTEGER, INTENT(IN OUT)                  :: bcdopt
!WKBR LOGICAL          BO,SP,CP,DP,MS,TAPEUP,TAPBIT,DEBUG
 LOGICAL :: bo,sp,cp,dp,ms,debug
 INTEGER :: outfil(5),trl(7),NAME(2),subnam(2),iz(1),  &
     skip(2),iname(2,5),oname(2,5),typ(5),t(2,5),ty(4),&
     flag
 REAL :: z(1),dr(2),d,zero(4)
 DOUBLE PRECISION :: dz(1),dd
 CHARACTER (LEN=11) :: fmd,unf,fm
!WKBI
 CHARACTER (LEN=80) :: dsnames
 CHARACTER (LEN=27) :: swm
 CHARACTER (LEN=25) :: sfm
 CHARACTER (LEN=29) :: uim
 CHARACTER (LEN=25) :: uwm
 CHARACTER (LEN=23) :: ufm
 COMMON /xmssg /  ufm,uwm,uim,sfm,swm
!WKBI
 COMMON / dsname / dsnames(80)
 COMMON /machin/  mach /packx /  typin,typout,ii,jj,incr  &
     /system/  sysbuf,nout,nogo,dum36(36),nbpw /TYPE  /  prec(2),nwds(4)  &
     /zzzzzz/  core(1)
 COMMON /BLANK /  p1,p2,p3(2),p4
 EQUIVALENCE      (iz(1),z(1),dz(1),core(1)), (dr(1),d,dd)
 DATA    outfil/  201,202,203,204,205 /, skip/4H(ski,4HP)  /
 DATA    iname ,  oname ,typ / 25*4H    /    ,subnam/4HINPT,2HT4  /
 DATA    ty    /  4HRSP ,4HRDP ,4HCSP ,4HCDP /, zero/4*0.0 /
 DATA    fmd   ,  unf / 'FORMATTED  ','UNFORMATTED' /blnk / 4H    /
 DATA    debug /  .false.    /
!WKBI
 DATA  ifirst / 0 /
 
 sp    = .false.
 cp    = .false.
 dp    = .false.
 ms    = p4 == -4
 bo    = bcdopt /= 1
 lcore = korsz(z(1))
 buf1  = lcore - sysbuf
 lcor  = buf1  - 1
 IF (lcor <= 0) CALL mesage (-8,lcore,subnam)
 IF (unitx < 10 .OR. unitx > 24) GO TO 30
 IF (unitx == 13) GO TO 30
 IF (mach == 4 .AND. unitx >= 13) GO TO 30
 IF (mach /= 4 .AND. unitx <= 13) GO TO 30
 
 fm = unf
 IF (bo) fm = fmd
!WKBR WRITE  (NOUT,10) UIM,UNITX,INP(UNITX-10),FM
 WRITE  (nout,10) uim,unitx,dsnames(unitx),fm
!    1,                BCDOPT,P1,P2,P3,P4
!WKBR10 FORMAT (A29,'. INPUTT4 MODULE OPENING FORTRAN TAPE',I4,' (',A4,
 10 FORMAT (a29,'. INPUTT4 MODULE OPENING FORTRAN TAPE',i4,/,' (',  &
     a44,')',/, ' FOR ',a11,' READ.')
!    2,      /5X,'BCDOPT,P1,P2,P3,P4 =',3I3,1X,2A4,I4)
 
!WKBR IF (MACH .GE. 5) GO TO 50
!WKBI
 CLOSE ( UNIT=unitx )
!WKBR OPEN (UNIT=UNITX,ACCESS='SEQUENTIAL',STATUS='OLD',FORM=FM,ERR=920)
 OPEN (UNIT=unitx,ACCESS='SEQUENTIAL',STATUS='OLD',FORM=fm,ERR=920, &
!WKBI  &
 FILE=dsnames(unitx) )
 GO TO 50
!WKBD FILE   = INP(UNITX-10)
!WKBD TAPEUP = TAPBIT(FILE)
!WKBD IF (TAPEUP) GO TO 50
!WKBD WRITE  (NOUT,20) UFM,FILE,UNITX
!WKBD 20 FORMAT (A23,'. ',A4,' (TAPE UNIT',I4,') NOT ASSIGNED')
!WKBD GO TO 990
 
 30 WRITE  (nout,40) ufm,unitx
 40 FORMAT (a23,', TAPE UNIT',i4,' SPEC. ERROR')
 GO TO 990
 
 50 IF (tape == -1 .OR. tape == -3) REWIND unitx
!WKBI
 ifirst = 1
 
!     SET UP LOOP TO READ MATRIX FILES
 
 incr  = 1
 ii    = 1
 DO  nn = 1,nmat
   
!     CHECK OUTPUT FILE REQUEST
   
   output = outfil(nn)
   trl(1) = output
   CALL rdtrl (trl)
   IF (trl(1) > 0) GO TO 200
   
!     IF OUTPUT FILE IS PURGED, PURGE THE CORRESPONDING FILE ON INPUT
!     TAPE. CHECK IF THERE ARE MORE OUTPUT DATA BLOCK REQUESTED ON THE
!     SAME OUTPUT2 DMAP. QUIT IF THERE ARE NONE
   
   i = nn
   100 i = i + 1
   IF (i > 5) GO TO 810
   trl(1) = outfil(i)
   CALL rdtrl (trl)
   IF (trl(1) <= 0) GO TO 100
   
!     SKIP PRESENT MATRIX DATA BLOCK ON INPUT TAPE
   
   imhere = 120
   IF (bo) GO TO 120
   
!     SKIP BINARY FILES
   
   imhere = 105
   READ (unitx,ERR=960,END=940) ncol,j1,j2,ntype,NAME
   imhere = -110
   110 READ (unitx,ERR=780,END=940) icol
   IF (icol-ncol > 0) THEN
     GO TO   170
   ELSE
     GO TO   110
   END IF
   
!     SKIP ASCII FILES
   
   120 IF (.NOT.ms) READ (unitx,220,ERR=960,END=940) ncol,j1,j2,ntype, NAME
   IF (ms) READ (unitx,230,ERR=960,END=940) ncol,j1,j2,ntype,NAME
   IF (ms) GO TO 130
   dp = ntype == 2 .OR. ntype == 4
   sp = .NOT.dp
   cp = p4 >= 1 .AND. nbpw >= 60
   IF (.NOT.cp) GO TO 130
   sp = .false.
   dp = .false.
   130 IF (ms) READ (unitx,440) icol,irow,nw
   IF (sp) READ (unitx,450) icol,irow,nw
   IF (cp .OR. dp) READ (unitx,460) icol,irow,nw
   IF (icol > ncol) GO TO 160
   IF (irow == 0) nw = nw/65536
   
!     COMPUTE NO. OF RECORDS TO SKIP.
   
!     S.P. DATA ARE WRITTEN IN 10 VALUES PER RECORD (5 FOR MSC RECORD)
!     D.P. DATA, AND DATA FROM LONG WORD MACHINE, ARE IN 8 VALUES PER
!     RECORD (SEE FORMAT 650, 660, 670 AND 680)
   
   IF (ms) nw = (nw+4)/5
   IF (sp) nw = (nw+9)/10
   IF (cp .OR. dp) nw = (nw+7)/8
   DO  j = 1,nw
     READ (unitx,140) k
     140 FORMAT (a1)
   END DO
   GO TO 130
   
   160 READ (unitx,140) j
   
   170 iname(1,nn) = NAME(1)
   iname(2,nn) = NAME(2)
   oname(1,nn) = skip(1)
   oname(2,nn) = skip(2)
   typ(nn) = ty(ntype)
   t(1,nn) = j1
   t(2,nn) = j2
   CYCLE
   
!     TRANSFER DATA FROM INPUT TAPE TO OUTPUT FILE
   
   200 imhere = 210
   IF (bo) GO TO 210
   imhere = 200
   READ (unitx,ERR=960,END=940) ncol,nrow,nform,ntype,NAME
   GO TO 240
   210 IF (.NOT.ms) READ (unitx,220,ERR=960,END=940) ncol,nrow,nform,  &
       ntype,NAME
   IF (ms) READ (unitx,230,ERR=960,END=940) ncol,nrow,nform,ntype, NAME
   220 FORMAT (1X,4I13,5X,2A4)
   230 FORMAT (4I8,2A4)
   
   240 IF (debug) WRITE (nout,220) ncol,nrow,nform,ntype,NAME
   IF (.NOT.debug) WRITE (nout,245) nn,NAME
   245 FORMAT (5X,'READING DATA BLOCK NO.',i4,' - ',2A4, ' FROM INPUT TAPE')
   
   IF (ms) nform = -nform
   IF (bo .AND. nform > 0) GO TO 900
   
!     THE ABOVE CHECK ON NFORM AND BO MAY BE ALREADY TOO LATE
   
   IF (ms) GO TO 250
   dp = .false.
   IF (ntype == 2 .OR. ntype == 4) dp = .true.
   sp = .NOT.dp
   cp = p4 >= 1 .AND. nbpw >= 60
   IF (cp) sp = .false.
   IF (cp) dp = .false.
   250 flag = 0
   IF (ms) flag = 1
   IF (sp) flag = 2
   IF (cp) flag = 3
   IF (dp) flag = 4
   IF (flag == 0) CALL mesage (-37,0,subnam)
   nform  = IABS(nform)
   jj     = nrow
   typin  = ntype
   IF (ms .AND. (typin == 2 .OR. typin == 4)) typin = typin - 1
   typout = ntype
   nwords = nwds(typin)
   base   = nrow*nwords
   IF (base > lcor) CALL mesage (-8,lcore,subnam)
   CALL makmcb (trl(1),output,nrow,nform,typout)
   iname(1,nn) = NAME(1)
   iname(2,nn) = NAME(2)
   CALL fname (output,NAME)
   CALL OPEN  (*260,output,iz(buf1),1)
   CALL WRITE (output,NAME,2,1)
   oname(1,nn) = NAME(1)
   oname(2,nn) = NAME(2)
   typ(nn) = ty(ntype)
   t(1,nn) = ncol
   t(2,nn) = nrow
   GO TO 280
   
   260 WRITE  (nout,270) ufm,dsnames(unitx)
   270 FORMAT (a23,'. CANNOT OPEN OUTPUT FILE - ',/,a80)
   GO TO 990
   
!     PROCESS EACH COLUMN (NON-ZERO OR NULL COLUMN ON FILE)
!     PLUS ONE EXTRA COLUMN, NCOL+1, AT THE END
   
   280 iold = -1
   ii = 1
   jj = nrow
   ncol1 = ncol + 1
   i  = 0
   
   290 i  = i + 1
   IF (debug) WRITE (nout,300) i,ncol1
   300 FORMAT ('   INPUT4/@290   I,NCOL1 =',2I5)
   IF (i > ncol1) GO TO 760
   DO  j = 1,base
     z(j) = 0.0
   END DO
   imhere = -400
   IF (bo) GO TO 400
   
!     BINARY (UNFORMATTED) READ
!     -------------------------
   
   imhere = -315
   READ (unitx,ERR=780,END=940) icol,irow,nw,(z(k+base),k=1,nw)
   
   IF (icol > ncol) GO TO 760
   IF (nw+base > lcor) CALL mesage (-8,lcore,subnam)
   320 IF (i >= icol) GO TO 330
   
!     NULL COLUMN(S) ENCOUNTERED
   
   jj = 1
   CALL pack (z(1),output,trl)
   jj = nrow
   i  = i + 1
   GO TO 320
   
   330 IF (irow == 0) GO TO 360
   
!     DENSE MATRIX FORMAT
   
!     DATA WERE WRITTEN FROM FIRST NON-ZERO TERM TO LAST NON-ZERO TERM
!     INCLUDING POSSIBLE ZERO TERMS.
!     IROW IS THE FIRST NON-ZERO TERM ROW POSITION
   
!     S.P. OR D.P. MATRIX IN, S.P. OR. D.P. MATRIX OUT. THAT INCLUDE
!     REAL AND COMPLEX.
   
   irowp = (irow-1)*nwords
   DO  j = 1,nw
     z(j+irowp) = z(j+base)
   END DO
   
!     PACK ONE COLUMN OUT
   
   350 CALL pack (z(1),output,trl)
   GO TO 290
   
!     SPARSE INCOMING MATRIX.
!     THIS RECORD CONATINS ONE OR MORE STRINGS.
   
!     DATA ARE WRITTEN IN MULTIPLE STRINGS OF NON-ZERO TERMS. EACH
!     STRING IS PRECEED BY A CONTROL WORD
!       LN   = LENGTH OF STRING, LEFT HALF OF WORD
!       IROW = ROW POSITION,    RIGHT HALF OF WORD
!       LN AND IROW ARE DATA TYPE DEPENDENT
!     AND
!       K    = A RUNNING POINTER, POINTS TO THE CONTROL WORD OF EACH
!              STRING IN ARRAY Z HOLDING LN AND IROW INFORMATION
   
   360 k    = 1
   370 kpb  = k + base
   ln   = iz(kpb)/65536
   irow = iz(kpb) - ln*65536
   irow = (irow-1)*nwords
   ln   = ln*nwords
   
!     S.P. OR D.P. MATRIX IN, S.P. OR. D.P. MATRIX OUT. THAT INCLUDE
!     REAL AND COMPLEX
   
   DO  j = 1,ln
     z(j+irow) = z(j+kpb)
   END DO
   k  = k + ln + 1
   IF (k-nw < 0) THEN
     GO TO   370
   ELSE
     GO TO   350
   END IF
   
!     ASCII (FORMATTED) READ
!     ----------------------
   
!     THIS ASCII OPTION WORKS WELL WITH INPUT TAPE GENERATED FROM
!     COSMIC/OUTPUT4 MODULE. HOWEVER IT MAY OR MAY NOT WORK WITH INPUT
!     TAPE FROM MSC/OUTPUT4.
   
!     ASSUMPTIONS HERE FOR MSC/OUTPUT4 TAPE ARE -
!     1. INTEGER RECORDS AND FLOATING POINT RECORDS DO NOT MIXED
!     2. ONE OR MORE RECORDS HOLD A MATRIX COLUMN, EACH RECORD IS LESS
!        THAN 80 BYTES LONG.
!        INTEGER IN 3I8, BCD IN 2A4, AND S.P. REAL DATA IN 5E16.9
   
   400 SELECT CASE ( flag )
     CASE (    1)
       GO TO 410
     CASE (    2)
       GO TO 420
     CASE (    3)
       GO TO 430
     CASE (    4)
       GO TO 430
   END SELECT
   410 READ (unitx,440,ERR=780,END=940) icol,irow,nw
   IF (debug) WRITE (nout,450) icol,irow,nw
   GO TO 470
   420 READ (unitx,450,ERR=780,END=940) icol,irow,nw
   GO TO 470
   430 READ (unitx,460,ERR=780,END=940) icol,irow,nw
   440 FORMAT (3I8)
   450 FORMAT (1X,3I13)
   460 FORMAT (1X,3I16)
   
!     ICOL IS MATRIX COLUMN NUMBER READ IN FROM THE INPUT TAPE.
!          REPEATED ICOL FOR MULTIPLE STRINGS.
!     IROW IS .LT. 0, AND IABS(IROW) IS THE ROW POSITION OF STRING.
!     NW   IS LENGTH OF STRING.
!     I    IS THE CURRENT COLUMN NUMBER OF THE OUTPUT MATRIX.
   
!     POSSIBILITIES AT THIS POINT ARE -
   
!     1. ICOL = IOLD, ADD NEW STRING TO CURRENT COLUMN OF OUTPUT MATRIX.
!     2. ICOL = IOLD+1, PREVIOUS COLUMN JUST FINISHED, PACK IT OUT.
!     3. ICOL.GT.NCOL, OUTPUT MATRIX FINISH. ALL COLUMNS HAVE BEEN READ.
!               READ ONE MORE DUMMY RECORD BEFORE WRAP UP THIS MATRIX
!     4. IN ALL CASES, ZERO OUT Z ARRAY FOR NEW DATA, AND INCREASE
!        COLUMN COUNTER I BY 1
!     5. ICOL .LT. I, LOGIC ERROR
!     6. ICOL .GT. I, PACK NULL COLUMN(S) OUT.
!     7. ICOL .EQ. I, CURRENT INPUT RECORD IS FOR THE I-TH COLUMN.
   
   470 IF (nw*nwords > lcor) CALL mesage (-8,lcore,subnam)
   IF (icol == iold  ) GO TO 710
   IF (icol == iold+1) CALL pack (z(1),output,trl)
   imhere = -550
   IF (icol > ncol) GO TO 550
   DO  j = 1,base
     z(j) = 0.0
   END DO
! 490 I = I + 1
   490 IF (icol - i < 0) THEN
     GO TO   510
   ELSE IF (icol - i == 0) THEN
     GO TO   600
   END IF
   500 CALL pack (z(1),output,trl)
   i = i + 1
   GO TO 490
   510 WRITE  (nout,520) sfm,i,icol, iold,ncol,irow,nw, sp,cp,dp,ms,flag
   520 FORMAT (a25,'. LOGIC ERROR @470, I,ICOL =',2I6, /5X,  &
       '  IOLD,NCOL,IROW,NW =',4I6,'  SP,CP,DP,MS,FLAG =',4L2,i4)
   CALL mesage (-37,0,subnam)
   
   550 READ (unitx,140,ERR=780,END=940) j
   GO TO 760
   
   600 IF (irow <= 0) GO TO 700
   
!     DENSE MATRIX FORMAT
   
   irow = irow - 1
   imhere = 605
   SELECT CASE ( flag )
     CASE (    1)
       GO TO 610
     CASE (    2)
       GO TO 620
     CASE (    3)
       GO TO 630
     CASE (    4)
       GO TO 640
   END SELECT
   610 READ (unitx,650,ERR=780,END=940) ( z(k+irow),k=1,nw)
   IF (debug) WRITE (nout,660) (z(k+irow),k=1,nw)
   GO TO 350
   620 READ (unitx,660,ERR=780,END=940) ( z(k+irow),k=1,nw)
   GO TO 350
   630 READ (unitx,670,ERR=780,END=940) ( z(k+irow),k=1,nw)
   GO TO 350
   640 READ (unitx,680,ERR=780,END=940) (dz(k+irow),k=1,nw)
   GO TO 350
   650 FORMAT (    5E16.9)
   660 FORMAT (1X,10E13.6)
   670 FORMAT (1X, 8E16.9)
   680 FORMAT (1X, 8D16.9)
   
!     SPARSE INCOMING MATRIX
   
!     OUTPUT4 WRITES OUT THE ASCII STRING DATA IN FOLLOWING FORMATS -
!     EACH STRING, PRECEEDED BY A 3-INTEGER - ICOL,IROW,NW - CONTROL
!     RECORD, AND CONTINUE INTO ONE OR MORE DATA RECORDS OF 130 OR
!     128 BYTES EACH. (80 BYTES MSC RECORD)
!     NW   = LENGTH OF STRING IN THE FOLLOWING DATA RECORDS, S.P. OR
!            D.P. DEPENDENT.
!     IROW = IABS(IROW) IS ROW POSITION IF FIRST WORD OF STRING
!     ICOL = COLUMN NUMBER OF MATRIX
   
!     NOTICE THAT OUTPUT4 MAY WRITE OUT A MATRIX COLUMN IN MULTI-STRING
!     RECORDS, WITH THE SAME COLUMN VALUE ICOL IN THE EACH 3-INTEGER
!     CONTROL RECORD. IN THIS CASE, MROW IS ALWAYS NEGATIVE.
!     (IF IROW IS ZERO, MATRIX WAS WRITTEN OUT IN DENSE FORMAT)
   
   700 iold = icol
   710 irow = IABS(irow) - 1
   IF (typin >= 3) irow = irow*2
   imhere = 715
   SELECT CASE ( flag )
     CASE (    1)
       GO TO 720
     CASE (    2)
       GO TO 730
     CASE (    3)
       GO TO 740
     CASE (    4)
       GO TO 750
   END SELECT
   720 READ (unitx,650,ERR=780,END=940) ( z(k+irow),k=1,nw)
   GO TO 400
   730 READ (unitx,660,ERR=780,END=940) ( z(k+irow),k=1,nw)
   GO TO 400
   740 READ (unitx,670,ERR=780,END=940) ( z(k+irow),k=1,nw)
   GO TO 400
   750 READ (unitx,680,ERR=780,END=940) (dz(k+irow),k=1,nw)
   GO TO 400
   
   760 CALL CLOSE  (output,1)
   CALL wrttrl (trl)
   IF (debug) WRITE (nout,770) uim,NAME,dsnames(unitx),trl
   770 FORMAT (a29,' FROM INPUTT4 MODULE. ',2A4,' WAS RECOVERED FROM ',  &
       /, a44,' INPUT TAPE SUCCESSFULLY.', /5X,'TRAIL =',6I6,i9)
   CYCLE
   
!     BAD DATA ON INPUT TAPE
   
   780 WRITE  (nout,790) ufm,dsnames(unitx),unitx,nn,imhere
   790 FORMAT (a23,'. BAD DATA ENCOUNTERED WHILE READING INPUT TAPE ',/,a80  &
       ,/,     ' FORTRAN UNIT',i4,',  DATA BLOCK',i4, /5X,'IMHERE =',i5)
   nogo = 1
   
 END DO
 
 810 IF (tape <= -2) REWIND unitx
 CALL page2 (-8)
!WKBR WRITE  (NOUT,820) UIM,FM,INP(UNITX-10)
 WRITE  (nout,820) uim,fm,dsnames(unitx)
 820 FORMAT (a29,' FROM INPUTT4 MODULE. THE FOLLOWING FILES WERE ',  &
     'SUCCESSFULLY RECOVERED FROM USER ',/5X,a11,' INPUT TAPE ', &
!WKBR2       /A80/,' TO NASTRAN GINO FILES')  &
     /,a44,' TO NASTRAN GINO FILES')
 DO  j = 1,5
   IF (iname(1,j) /= blnk) WRITE (nout,830) iname(1,j),iname(2,j),  &
       oname(1,j),oname(2,j),typ(j),t(1,j),t(2,j)
   830 FORMAT (5X,2A4,' ==COPIED TO== ',2A4,4X,'MATRIX TYPE = ',a4,  &
       ',  SIZE (',i6,2H x,i6,1H))
 END DO
 GO TO 1000
 
!     ERRORS
 
 900 WRITE  (nout,910) ufm,dsnames(unitx),bo,ncol,nrow,nform,ntype,  &
     NAME,bcdopt
 910 FORMAT (a23,'. PARAMETER P3 ERROR. FORTRAN INPUT TAPE ',a4,' WAS',  &
     ' WRITTEN IN BINARY RECORDS, NOT ASCII.', /5X,'BO =',l2,2X,  &
     'NCOL,NROW,NFORM,NTYPE,NAME =',4I8,1X,2A4,'   BCDOPT =',i3)
 GO TO  990
 920 WRITE  (nout,930) ufm,unitx
 930 FORMAT (a23,'. INPUTT4 MODULE CANNOT OPEN FORTRAN INPUT TAPE',i4)
 GO TO  990
 940 WRITE  (nout,950) ufm,dsnames(unitx),unitx,nn,imhere
 950 FORMAT (a23,' 3001, EOF ENCOUNTERED WHILE READING INPUT TAPE ',/,a80  &
     ,/,    ' FORTRAN UNIT',i4,',  DATA BLOCK',i4, /5X,'IMHERE =',i4)
 IF (imhere == 210 .OR. imhere == 220) WRITE (nout,975)
 GO TO 990
 960 WRITE  (nout,970) ufm,dsnames(unitx),unitx,nn,imhere
 970 FORMAT (a23,'. BAD DATA IN HEADER RECORD ON INPUT TAPE ', /,a80,/  &
     , ' FORTRAN UNIT',i4,',  DATA BLOCK',i4, /5X,'IMHERE =',i5)
 IF (imhere == 105 .OR. imhere == 120) WRITE (nout,975)
 975 FORMAT (1H+,22X,'POSSIBLY TAPE UNIT NOT CORRECTLY ASSIGNED')
 IF (imhere < 0) WRITE (nout,980)
 980 FORMAT (1H+,22X,'POSSIBLY ERROR IN CONTRL RECORD 3 WORDS')
 
 990 nogo = 1
 
!WKBR 1000 CLOSE (UNIT=UNITX)
 1000 CONTINUE
 RETURN
END SUBROUTINE input4
